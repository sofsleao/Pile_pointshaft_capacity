# -*- coding: utf-8 -*-
"""0 - Programa para o Usuário.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ol9WxT9qg0lV8toXE8jgchYPWLyhxFOL

#Cálculo de carga de Ponta e Fuste de Estacas Hélice-Contínuas usando Redes Neurais Artificiais

##Bibliotecas e Definições de Impressão
"""

import pandas as pd
from datetime import datetime
import matplotlib.pyplot as plt
import sys
from sklearn.preprocessing import MinMaxScaler

#Impressão Gráficos
impressao = True  # Altere para True se quiser imprimir gráficos

"""##Leitura dos Dados da Estaca a partir de um arquivo .csv (do tipo utf-8)"""

# Perguntar ao usuário o nome do arquivo de entrada
nome_arq = input("Digite o nome do arquivo CSV (sem a extensão .csv): ")

# Adiciona a extensão .csv
nome_arquivo = nome_arq + ".csv"

# Leitura do arquivo CSV especificando a codificação e delimitador
dados = pd.read_csv(nome_arquivo, encoding='utf-8', delimiter=';', header=None)

# Exibindo as primeiras linhas para inspeção
#print(dados.head(5))  # Mostra as 5 primeiras linhas

# Extraindo os dados específicos conforme suas localizações
diametro =  float(dados.iloc[2, 1])  # Linha 3 (índice 2), Coluna B (índice 1)
comprimento =  float(dados.iloc[2, 2])  # Linha 3 (índice 2), Coluna C (índice 2)
tipo_estaca = dados.iloc[2, 3]  # Linha 3 (índice 2), Coluna D (índice 3)
cota_inicio = float(dados.iloc[2, 4])  # Linha 3 (índice 2), Coluna E (índice 4)
cota_termino = float(dados.iloc[2, 5])  # Linha 3 (índice 2), Coluna F (índice 5)
id_estaca = dados.iloc[2, 0]  # ID na coluna A (índice 0)
data_analise = dados.iloc[2, 6]  # Data na coluna G (índice 6)
cidade = dados.iloc[2, 7]
estado = dados.iloc[2, 8]

# Exibindo as Informações Gerais
print(f"ID da Estaca: {id_estaca}")
print(f"Cidade: {cidade}")
print(f"Cidade: {estado}")
print(f"Diametro: {diametro} m")
print(f"Comprimento: {comprimento} m")
print(f"Tipo de Estaca: {tipo_estaca}")
print(f"Cota de Início: {cota_inicio} m")
print(f"Cota de Término: {cota_termino} m")
print(f"Data da Análise: {data_analise}")

# Leitura dos dados SPT
# Pula as linhas de cabeçalho e pega as linhas relevantes
dados_spt = pd.read_csv(nome_arquivo, encoding='utf-8', delimiter=';', skiprows=5, header=None)

# Filtrando apenas as colunas relevantes
dados_spt = dados_spt[[0, 1]]  # Selecionando apenas as colunas de Profundidade e NSPT
dados_spt.columns = ['Profundidade (m)', 'NSPT']  # Renomeando as colunas

# Convertendo os dados para tipo numérico
dados_spt['Profundidade (m)'] = pd.to_numeric(dados_spt['Profundidade (m)'], errors='coerce')
dados_spt['NSPT'] = pd.to_numeric(dados_spt['NSPT'], errors='coerce')

# Verificação de valores nulos ou inválidos em colunas importantes
if dados_spt['Profundidade (m)'].isnull().any():
    print("Atenção: Existem valores nulos ou inválidos na coluna 'Profundidade (m)'.")
if dados_spt['NSPT'].isnull().any():
    print("Atenção: Existem valores nulos ou inválidos na coluna 'NSPT'.")

# Verificação de tipos de dados nas colunas de profundidade e NSPT
if not pd.api.types.is_numeric_dtype(dados_spt['Profundidade (m)']):
    print("Erro: A coluna 'Profundidade (m)' contém valores não numéricos.")
if not pd.api.types.is_numeric_dtype(dados_spt['NSPT']):
    print("Erro: A coluna 'NSPT' contém valores não numéricos.")

# Verificando se as cotas de início e término coincidem com as profundidades SPT
prof_minima = dados_spt['Profundidade (m)'].min()
prof_maxima = dados_spt['Profundidade (m)'].max()

# Validação das cotas
if abs(prof_minima - cota_inicio) > 0.1:
    print(f"Atenção: A cota de início {cota_inicio} não coincide com a profundidade mínima nos dados SPT ({prof_minima}).")
else:
    print("Cota de início está correta.")

if abs(prof_maxima - cota_termino) > 0.1:
    print(f"Atenção: A cota de término {cota_termino} não coincide com a profundidade máxima nos dados SPT ({prof_maxima}).")
else:
    print("Cota de término está correta.")

# Verificando se a cota de término da estaca está dentro dos limites de profundidade dos dados SPT
if cota_termino > prof_maxima:
    print(f"Atenção: A cota de término {cota_termino} está abaixo da profundidade máxima dos dados SPT ({prof_maxima}).")
    sys.exit()  # Para o programa se a cota de término não for válida
else:
    print("Cota de término está dentro dos limites dos dados SPT.")

# Mostra o conteúdo dos dados de SPT
print(dados_spt)

# Leitura do arquivo CSV para solo PCEB
if impressao:
    # Exemplo: plotar profundidade vs NSPT
    plt.figure(figsize=(6, 6))
    plt.plot(dados_spt['NSPT'], dados_spt['Profundidade (m)'], linestyle='-', color='r')
    plt.gca().invert_yaxis()  # Inverter eixo Y para profundidade crescente para baixo
    plt.xlabel('NSPT')
    plt.ylabel('Profundidade (m)')
    plt.title(f'Perfil de NSPT da {id_estaca} - Data: {data_analise}')
    plt.savefig('grafico_nspt.png')  # Salva o gráfico como PNG
    plt.show()
else:
    print(f"  ")

"""##Interpolação dos 40 pontos de NSPT ao longo do fuste da estaca

"""

import numpy as np

# Definindo cota inicial, cota final e número de pontos
cota_inicio = float(cota_inicio)  # Convertendo para float
cota_termino = float(cota_termino)  # Convertendo para float
n_pontos = 40      # Número de pontos desejados

# Interpolando os 40 pontos entre cota inicial e cota final
cotainterpolada = np.linspace(cota_inicio, cota_termino, n_pontos)

# Inicializando listas para armazenar os valores
cotas = []         # Lista para armazenar as cotas interpoladas
Cxi_values = []    # Lista para armazenar os valores de Cxi
Cyi_values = []    # Lista para armazenar os valores de Cyi

# Exibindo os pontos interpolados
for i, cota in enumerate(cotainterpolada, start=1):
    Cxi = cota  # Ponto atual
    Cx0 = int(np.floor(Cxi))  # Ponto anterior (inteiro)
    Cx = int(np.ceil(Cxi))  # Próximo ponto (inteiro)
    # Obtendo os valores de NSPT correspondentes para Cy0 e Cy
    Cy0 = dados_spt.loc[dados_spt['Profundidade (m)'] == Cx0, 'NSPT'].values
    Cy = dados_spt.loc[dados_spt['Profundidade (m)'] == Cx, 'NSPT'].values

    # Usando 0 se não houver um valor correspondente
    Cy0 = Cy0[0] if Cy0.size > 0 else 0
    Cy = Cy[0] if Cy.size > 0 else 0

    # Calcular Cyi usando a fórmula fornecida
    if Cx != Cx0:  # Verifica se a divisão não irá causar erro
        Cyi = ((Cy - Cy0) / (Cx - Cx0)) * (Cxi - Cx0) + Cy0
    else:
        Cyi = Cy0  # Se Cx == Cx0, atribui o valor de Cy0 a Cyi

    # Adiciona os valores às listas
    cotas.append(cota)
    Cxi_values.append(Cxi)
    Cyi_values.append(Cyi)

    # Imprimindo os resultados
    #print(f'Ponto {i}: {cota:.2f} m, Cxi: {Cxi:.2f}, Cx0: {Cx0}, Cx: {Cx}, Cy0: {Cy0}, Cy: {Cy}, Cyi: {Cyi:.2f}')
    #print(f'Ponto {i}: {cota:.2f} m, Cxi: {Cxi:.2f}, Cyi: {Cyi:.2f}')

# Leitura do arquivo CSV para solo PCEB
if impressao:
    # Criando o gráfico
    plt.figure(figsize=(6, 6))
    plt.plot(Cyi_values, cotas, marker='o', linestyle='-', color='b', label='Interpolação NSPT - 40 pontos')
    plt.title('Valores de Cyi em Função da Profundidade Interpolada')
    plt.xlabel('Profundidade (m)')  # Eixo X: Profundidade
    plt.ylabel('NSPT')   # Eixo Y: Cyi
    plt.grid()
    plt.axhline(0, color='black', linewidth=0.5, ls='--')
    plt.axvline(0, color='black', linewidth=0.5, ls='--')
    # Invertendo o eixo Y
    plt.gca().invert_yaxis()  # Coloca o zero no topo
    plt.legend()
    plt.savefig('40pontos_NSPT_ESTACA.png')  # Salva o gráfico como PNG
    plt.show()
else:
    print(f"Impressão de Gráfico desativada")

"""##Cálculo das Médias de NSPT do fuste e NSPT da ponta"""

# Inicializando listas para armazenar os resultados das médias
NSPT_values = []

# Calculando as médias para cada grupo de 10 pontos
for i in range(4):  # Para os quatro grupos
    start_index = i * 10  # Índice inicial do grupo
    end_index = start_index + 10  # Índice final do grupo
    NSPT = np.mean(Cyi_values[start_index:end_index])  # Calculando a média
    NSPT_values.append(NSPT)  # Adicionando à lista

# Imprimindo os resultados
for i, NSPT in enumerate(NSPT_values, start=1):
    print(f'NSPTfuste{i}: {NSPT:.2f}')

# Filtrar os valores acima da cota final da estaca (ou seja, profundidades maiores que a cota_termino)
dados_filtrados = dados_spt[dados_spt['Profundidade (m)'] > cota_termino]

# Se houver dados filtrados, pegar o primeiro valor (o mais próximo logo abaixo da cota término)
if not dados_filtrados.empty:
    nspt_ponta_estaca = dados_filtrados.iloc[0]['NSPT']  # Primeiro valor de NSPT logo abaixo da cota término
else:
    nspt_ponta_estaca = None  # Caso não haja profundidades maiores que a cota final

# Exibir o NSPT da ponta da estaca
if nspt_ponta_estaca is not None:
    print(f'NSPT Ponta: {nspt_ponta_estaca}')
else:
    print(f'Não há dados de NSPT abaixo da cota final de {cota_termino} m.')

"""##Vetor de Entrada de Dados"""

# Criando o vetor de saída
vetor_entrada = {
    'Diâmetro': diametro,
    'Comprimento': comprimento,
    'NSPTfuste1': NSPT_values[0],
    'NSPTfuste2': NSPT_values[1],
    'NSPTfuste3': NSPT_values[2],
    'NSPTfuste4': NSPT_values[3],
    'NSPT Ponta': nspt_ponta_estaca
}

# Exibindo o vetor de saída
print(vetor_entrada)

# Imprimindo apenas os valores do vetor de saída
print(list(vetor_entrada.values()))

entrada = np.array(list(vetor_entrada.values())).reshape(1, -1)

"""##Função de Normalização dos dados"""

def min_max_normalize_columns(matrix, min_values=None, max_values=None):
    # Create a copy of the matrix to avoid modifying the original data
    normalized_matrix = matrix.copy()

    # Get the number of columns in the matrix
    num_columns = normalized_matrix.shape[1]

    # Create a MinMaxScaler instance
    scaler = MinMaxScaler()

    # If min_values and max_values are provided, use them for normalization
    if min_values is not None and max_values is not None:
        for column_index in range(num_columns):
            column = normalized_matrix[:, column_index]
            min_value = min_values[column_index]
            max_value = max_values[column_index]
            # Normalize the column based on provided min and max values
            normalized_column = (column - min_value) / (max_value - min_value)
            normalized_matrix[:, column_index] = normalized_column

    else:
        # Normalize using the default MinMaxScaler if no min/max values provided
        for column_index in range(num_columns):
            column = normalized_matrix[:, column_index]
            column = column.reshape(-1, 1)
            normalized_column = scaler.fit_transform(column)
            normalized_column = normalized_column.flatten()
            normalized_matrix[:, column_index] = normalized_column

    return normalized_matrix

"""##Normalização dos dados"""

#Definição dos valores máximos e mínimos para normalização
max_values = [1.5,40,50,50,50,50,50]  #Lista dos valores máximos por coluna
min_values = [0.1,0.5,0,0,0,0,0]  #Lista dos valores mínimos por coluna

#Valores máximos e Mínimos para o set de dados de saída
max_output = [7000, 7000]  # Lista dos valores máximos por coluna
min_output = [0, 0]  # Lista dos valores mínimos por coluna


Input=min_max_normalize_columns(entrada, min_values, max_values)

print(Input)

"""##Previsão com o modelo de RNA"""

from tensorflow.keras.models import load_model

# Carregar o modelo salvo apenas para previsões
model = load_model('Modelo_Calibrado.h5')

# Usando o modelo para previsões
# Exemplo de entrada (substitua com os seus dados reais)
predicoes = model.predict(Input)

# Exibir previsões
print(predicoes)

#Dados treinamento e teste do Fuste de volta da normalização
max_PL = max_output[0]
Plateral=predicoes[:,0]*max_PL
print(f'Valor da Carga Lateral da Estaca {Plateral} kN.')

#Dados treinamento e teste da Ponta de volta da normalização
max_PP=max_output[1]
PPonta=predicoes[:,1]*max_PP
print(f'Valor da Carga de Ponta da Estaca {PPonta} kN.')

#Dados treinamento e teste da Ponta de volta da normalização
PTotal=Plateral+PPonta
print(f'Valor da Carga Total da Estaca {PTotal} kN.')

"""##Impressão PDF"""

pip install fpdf

from fpdf import FPDF

# Criando a classe PDF personalizada
class PDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 12)
        self.cell(0, 10, 'Título do Documento', 0, 1, 'C')

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Página {self.page_no()}', 0, 0, 'C')

# Criando o PDF
pdf = FPDF()

# Adicionar uma página
pdf.add_page()

# Definir o título
pdf.set_font('Arial', 'B', 16)
pdf.cell(0, 10, "Previsão da Capacidade de Carga de Estacas ", ln=True, align="C")
pdf.cell(0, 10, "Hélice Contínuas por meio de Redes Neurais", ln=True, align="C")
pdf.set_font('Arial', 'B', 14)
pdf.cell(0, 10, f"Relatório da Estaca {id_estaca}", ln=True, align="C")

# Adicionar informações gerais
pdf.set_font('Arial', '', 10)
pdf.cell(60, 10, f"ID da Estaca: {id_estaca}", border=1, ln=1)
pdf.cell(60, 10, f"Cidade: {cidade}", border=1, ln=0)
pdf.cell(60, 10, f"Estado: {estado}",  border=1, ln=1)
pdf.cell(60, 10, f"Diametro: {diametro} m", border=1, ln=0)
pdf.cell(60, 10, f"Comprimento: {comprimento} m", border=1, ln=1)
pdf.cell(60, 10, f"Tipo de Estaca: {tipo_estaca}", border=1, ln=1)
pdf.cell(60, 10, f"Cota de Início da estaca: {cota_inicio} m",  border=1, ln=0)
pdf.cell(60, 10, f"Cota de Término da estaca: {cota_termino} m", border=1, ln=1)
pdf.cell(60, 10, f"Data da Análise: {data_analise}", border=1, ln=1)

# Inserir o gráfico SPT no PDF
pdf.image('grafico_nspt.png', x=10, y=120, w=120)

# Mover o cursor para baixo após a imagem (altura aproximada da imagem)
pdf.ln(220)  # Ajuste o valor de acordo com o tamanho da sua imagem

# Definir o título 40 pontos
pdf.set_font('Arial', 'B', 12)
pdf.cell(0, 10, f"40 pontos interpolados do NSPT na estaca {id_estaca}", ln=True, align="L")

# Inserir o gráfico dos 40 pontos de NSPT na estaca no PDF
pdf.image('40pontos_NSPT_ESTACA.png', x=10, y=20, w=120)

# Mover o cursor para baixo após a imagem
pdf.ln(120)  # Ajuste novamente o valor de acordo com o tamanho da segunda imagem

# Médias de NSPT para entrada de dados
pdf.set_font('Arial', 'B', 10)
pdf.cell(50, 10, f"Médias de NSPT do fuste e NSPT da ponta {id_estaca}", ln=True, align="L")
pdf.set_font('Arial', '', 10)
pdf.cell(50, 10, f"NSPTfuste1: {NSPT_values[0]:.2f}",border=1, ln=0)
pdf.cell(50, 10, f"NSPTfuste2: {NSPT_values[1]:.2f}",border=1, ln=1)
pdf.cell(50, 10, f"NSPTfuste3: {NSPT_values[2]:.2f}",border=1, ln=0)
pdf.cell(50, 10, f"NSPTfuste4: {NSPT_values[3]:.2f}",border=1, ln=1)
pdf.cell(50, 10, f"NSPT Ponta: {nspt_ponta_estaca:.2f}",border=1, ln=1)

# Entradas de Dados na RNA
pdf.set_font('Arial', 'B', 10)
pdf.cell(0, 10, "Entradas de Dados na RNA", ln=True, align="L")
pdf.set_font('Arial', '', 10)
#pdf.cell(0, 10, f"{vetor_entrada}", ln=True)
pdf.cell(50, 10, f"Diâmetro: {diametro:.2f} m", border=1, ln=0)
pdf.cell(50, 10, f"Comprimento: {comprimento:.2f} m", border=1, ln=1)
pdf.cell(50, 10, f"NSPTfuste1: {NSPT_values[0]:.2f}", border=1, ln=0)
pdf.cell(50, 10, f"NSPTfuste2: {NSPT_values[1]:.2f}", border=1, ln=1)
pdf.cell(50, 10, f"NSPTfuste3: {NSPT_values[2]:.2f}", border=1, ln=0)
pdf.cell(50, 10, f"NSPTfuste4: {NSPT_values[3]:.2f}", border=1, ln=1)
pdf.cell(50, 10, f"NSPT Ponta: {nspt_ponta_estaca:.2f}", border=1, ln=1)

# Carga de Fuste, Ponta e Total calculada pela RNA
pdf.set_font('Arial', 'B', 10)
pdf.cell(1, 10, "Carga de Fuste, Ponta e Total calculada pela RNA", ln=True, align="L")
pdf.set_font('Arial', '', 10)
pdf.cell(100, 10, f"Valor da Carga Lateral da Estaca: {Plateral[0]:.2f} kN.", border=1, ln=1)
pdf.cell(100, 10, f"Valor da Carga de Ponta da Estaca: {PPonta[0]:.2f} kN.", border=1, ln=1)
pdf.cell(100, 10, f"Valor da Carga Total da Estaca: {PTotal[0]:.2f} kN.", border=1, ln=1)

# Salvar o arquivo PDF
pdf.output("Relatorio_RNA_cargas.pdf")